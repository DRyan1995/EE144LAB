% initialize

rosshutdown % to 'close' any previous sessions
rosinit('192.168.191.2'); % initialize Matlab ROS node
tbot = turtlebot  % the data structure that allows access to the turtlebot and its sensors
tbot.ColorImage.TopicName = '/usb_cam/image_raw/compressed'; % set netbook webcam as the camera for tbot

% these are the variables that are used to define the robot velocity
lin_vel = 0;  % meters per second
rot_vel = 0;  % rad/second

odometry_timer = timer('TimerFcn','curr_pose = get_pose_from_tbot_odometry(tbot);','Period',0.1,'ExecutionMode','fixedRate');
% start the timer. This will keep running until we stop it.
start(odometry_timer)

% create a Matlab "timer" for continuoulsy sending velocity commands to the robot.
% This will create a new thread that runs the command setVelocity(tbot,lin_vel,rot_vel) every 50msec
velocity_command_timer = timer('TimerFcn','setVelocity(tbot,lin_vel,rot_vel)','Period',0.05,'ExecutionMode','fixedSpacing');
% start the timer. This will keep running until we stop it.
start(velocity_command_timer)

% the following loop reads and stores 20 images from the camera
for i = 1:20

	rgbImg = getColorImage(tbot);
 	imwrite(rgbImg,['image',num2str(i),'.bmp']);


end

% the following loop reads the stored images, and displays them
for i = 1:20

	rgbImg = imread(['image',num2str(i),'.bmp']);
 	figure(10)
	subplot(4,5,i)
	imshow(rgbImg)

end

MOD = 0; % MODE parameter, default 0
while 1
  rgbImg = getColorImage(tbot);
	% display the image
	figure(11)
	imshow(rgbImg)

	% turn the image to hsv
	hsvImg = rgb2hsv(rgbImg);

	%% YOUR CODE HERE
    greenImg = zeros(size(hsvImg(:,:,1))); %declaring the greemImg
		redImg = zeros(size(hsvImg(:,:,1))); %declaring the greemImg
    for i = 1:size(hsvImg,1)
        for j = 1:size(hsvImg,2)
            if hsvImg(i,j,1)>(0.28) && hsvImg(i,j,1)<(0.33)  %putting threshold to identify green color
                greenImg(i,j)=true;
            else
                greenImg(i,j)=false;
            end
        end
    end
    for i = 1:size(hsvImg,1)
        for j = 1:size(hsvImg,2)
            if hsvImg(i,j,1)>(0.850)
                redImg(i,j)=true;
            else
                redImg(i,j)=false;
            end
        end
    end

		redImg = bwareafilt(logical(redImg),1); % this filter function is to eliminate the noise generated by the image processing
    figure(13)
    imshow(greenImg)
		figure(14)
		imshow(redImg)
    centroid_green = regionprops(greenImg, 'centroid'); % using regionprops to get the centroid of the binary image
    area_green = regionprops(greenImg, 'area'); % using regionprops to get the area of the binary image
    centroid_red = regionprops(redImg, 'centroid'); % using regionprops to get the centroid of the binary image
    area_red = regionprops(redImg, 'area'); % using regionprops to get the area of the binary image

		redX = 0;
		redArea = 1;
    greenX = 0; % store the X of the centroid of the green cylinder
    greenArea = 1; % store the area of the green cylinder
    if size(centroid_green,1) == 0
        disp('none green')
    else
        greenX = centroid_green.Centroid(1);
        greenArea = area_green.Area(1);
    end
    if size(centroid_red,1) == 0
        disp('none red')
    else
        redX = centroid_red.Centroid(1);
        redArea = area_red.Area(1);
    end

		%parameter initialization
		THRESHOLD = 20;
		kpl = 0.00005;
		kpr = 0.003;
		lin_current_error = 3100 - redArea;
		rot_current_error = 320 - redX;
		if MOD == 0 % making sure the area of the cylinder is 23000
					if abs(lin_current_error) + abs(rot_current_error) >=  THRESHOLD && redArea >= 1000 % when the greenArea is too small, we just consider there is no target in the camera view
							lin_current_error = 3100 - redArea;
							rot_current_error = 320 - redX;
							lin_vel = kpl * lin_current_error
							rot_vel = kpr * rot_current_error
					else
							if redArea >= 1000
									MOD = 1 % MOD 1 is for final approach -- just heading for the centroid of the cylinder
									posx = curr_pose(1) % recording the current X for future calculation
									posy = curr_pose(2) % recodring the current Y for future calculation
									postheta = curr_pose(3) % recording the current theta for future calculation
							else % there is no target cylinder in sight, just rotate itself to find the target
								rot_vel = 0.5;
								lin_vel = 0;
							end
					end
		else
				if MOD == 1
						lin_vel = 0;
						THRESHOLD = 6;
						kpr = 0.0035;
						rot_current_error = 320 - greenX;
						if abs(rot_current_error) >= THRESHOLD && greenArea >= 8000
								rot_current_error = 320 - greenX;
								rot_vel = kpr * rot_current_error;
						else
								if greenArea >= 8000
										MOD = 2
										theta1 = curr_pose(3)
										rot_vel = 0
								else
										rot_vel = 0.5;
										lin_vel = 0;
								end
						end
				else
						 	if MOD == 2 % MOD 1 can be considered a waypoint following approach
								  R = 0.64;
									k_p = 3;
									cx = posx + R * cos(postheta)
									cy = posy + R * sin(postheta)

									alpha = atan2((posy - cy)/R, (posx - cx)/R)
									beta = postheta - theta1

									waypoints = [cx+R*cos(alpha - 2 * beta);cy+R*sin(alpha - 2 * beta)] % we calculate the target point which is also the centroid of the bottom circle of the cylinder
								  if norm(curr_pose(1:2)- [cx+R*cos(alpha - 2 * beta);cy+R*sin(alpha - 2 * beta)])> 0.02 % the allowed error for this PID control is 2 cm
									R = [cos(curr_pose(3)) -sin(curr_pose(3)) 0 ;
									     sin(curr_pose(3)) cos(curr_pose(3))  0
										 0                      0             1];
								    R_p  = R'*([waypoints(:)-curr_pose(1:2) ; 0]);
									theta = atan2(R_p(2),R_p(1));
									rot_vel = sign(theta)* min(abs(k_p* theta), 1);
									lin_vel = min(0.12, max(0,0.12-0.5*abs(rot_vel)));
									else
											MOD = 3
									end
							else
									if MOD == 3
											THRESHOLD = 30;
											kpl = 0.00008;
											kpr = 0.003;
											lin_current_error = 4500 - redArea;
											rot_current_error = 320 - redX;
											if abs(lin_current_error) + abs(rot_current_error) >=  THRESHOLD && redArea >= 1000 % when the greenArea is too small, we just consider there is no target in the camera view
													lin_current_error = 4500 - redArea;
													rot_current_error = 320 - redX;
													lin_vel = kpl * lin_current_error
													rot_vel = kpr * rot_current_error
											else
													if redArea >= 1000
															MOD = 4 % MOD 1 is for final approach -- just heading for the centroid of the cylinder
															rot_vel = 0;
															lin_vel = 1;
													else % there is no target cylinder in sight, just rotate itself to find the target
															rot_vel = 0.5;
															lin_vel = 0;
													end
											end
									end
							end
					end
		end



end
